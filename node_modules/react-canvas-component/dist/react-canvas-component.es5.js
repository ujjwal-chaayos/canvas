'use strict';

function _interopDefault(ex) {
  return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex;
}

var React = require('react');
var React__default = _interopDefault(React);

var _createClass = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function(Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _objectWithoutProperties(obj, keys) {
  var target = {};
  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }
  return target;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var ReactCanvasComponent = function(_Component) {
  _inherits(ReactCanvasComponent, _Component);
  _createClass(ReactCanvasComponent, [{
    key: 'getChildContext',
    value: function getChildContext() {
      var context = this.context,
        props = this.props,
        canvasElement = this.canvasElement;
      var ctx = context && context.ctx || canvasElement && canvasElement.getContext('2d');
      var realtime = context && context.realtime || props.realtime;
      return {
        ctx: ctx,
        realtime: realtime
      };
    }
  }]);
  function ReactCanvasComponent(props) {
    _classCallCheck(this, ReactCanvasComponent);
    var _this = _possibleConstructorReturn(this, (ReactCanvasComponent.__proto__ || Object.getPrototypeOf(ReactCanvasComponent)).call(this, props));
    _this.refDOM = _this.refDOM.bind(_this);
    _this.requestAnimationFrameCallback = _this.requestAnimationFrameCallback.bind(_this);
    return _this;
  }

  _createClass(ReactCanvasComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.forceUpdate();
      requestAnimationFrame(this.requestAnimationFrameCallback);
    }
  }, {
    key: 'refDOM',
    value: function refDOM(element) {
      this.canvasElement = element;
    }
  }, {
    key: 'render',
    value: function render() {
      var props = this.props,
        context = this.context;
      var draw = props.draw,
        realtime = props.realtime,
        top = props.top,
        left = props.left,
        other = _objectWithoutProperties(props, ['draw', 'realtime', 'top', 'left']);
      requestAnimationFrame(this.requestAnimationFrameCallback);
      if (context.ctx) {
        return React__default.createElement('div', Object.assign({
          key: "canvas"
        }, other), [props.children]);
      }
      return React__default.createElement('canvas', Object.assign({
        ref: this.refDOM,
        key: "canvas"
      }, other), [props.children]);
    }
  }, {
    key: 'requestAnimationFrameCallback',
    value: function requestAnimationFrameCallback(time) {
      if (this.previousFrameTime !== time) {
        var props = this.props,
          context = this.context,
          canvasElement = this.canvasElement;
        var draw = props.draw,
          top = props.top,
          left = props.left;
        var ctx = context && context.ctx || canvasElement && canvasElement.getContext('2d');
        var realtime = context && context.realtime || props.realtime;
        var delta = 0;
        if (!draw || !ctx) {
          return;
        }
        if (realtime) {
          requestAnimationFrame(this.requestAnimationFrameCallback);
          if (this.previousFrameTime) {
            delta = time - this.previousFrameTime;
          } else {
            this.previousFrameTime = time;
          }
          this.previousFrameTime = time;
        }
        if (top || left) {
          ctx.translate(left, top);
        }
        draw({
          time: time,
          delta: delta,
          ctx: ctx
        });
        if (top || left) {
          ctx.translate(-1 * left, -1 * top);
        }
      }
    }
  }]);
  return ReactCanvasComponent;
}(React.Component);
ReactCanvasComponent.defaultProps = {
  draw: function() {},
  realtime: false,
  top: 0,
  left: 0
};
ReactCanvasComponent.propTypes = {
  draw: React.PropTypes.func,
  realtime: React.PropTypes.bool,
  top: React.PropTypes.number,
  left: React.PropTypes.number
};
ReactCanvasComponent.contextTypes = {
  ctx: React.PropTypes.object,
  realtime: React.PropTypes.bool
};
ReactCanvasComponent.childContextTypes = {
  ctx: React.PropTypes.object,
  realtime: React.PropTypes.bool
};

module.exports = ReactCanvasComponent;
